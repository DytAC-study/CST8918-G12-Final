name: Complete CI/CD Pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'modules/**'
      - 'environments/**'
      - 'weather-app/**'
      - '.github/workflows/complete-pipeline.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'modules/**'
      - 'environments/**'
      - 'weather-app/**'
      - '.github/workflows/complete-pipeline.yml'

permissions:
  id-token: write
  contents: read

jobs:
  # Step 1: Code Quality & Security
  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Format Check
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        run: |
          cd modules/network
          terraform init -backend=false
          terraform validate
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Security Scan
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          working_directory: modules

  # Step 2: Build & Deploy Infrastructure
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: code-quality
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Deploy to all environments using simple approach
      - name: Deploy Infrastructure
        run: |
          echo "=== Deploying Infrastructure ==="
          
          # Function to deploy environment
          deploy_env() {
            local env=$1
            echo "Deploying $env environment..."
            
            cd environments/$env
            
            # Simple approach: just apply without complex state management
            terraform init -backend=false
            terraform apply -auto-approve -lock=false -refresh=false
            
            echo "$env environment deployed successfully!"
          }
          
          # Deploy all environments
          deploy_env "dev"
          deploy_env "test" 
          deploy_env "prod"
          
          echo "All infrastructure deployed successfully!"

  # Step 3: Deploy Applications
  deploy-applications:
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Deploy applications to Kubernetes
      - name: Deploy Applications
        run: |
          echo "=== Deploying Applications ==="
          
          # Deploy to test environment
          echo "Deploying to test environment..."
          az aks get-credentials --resource-group cst8918-final-project-group-1 --name test-aks --overwrite-existing
          kubectl apply -f environments/test/weather-service.yaml
          kubectl rollout status deployment/weather-app -n default --timeout=180s
          
          # Deploy to production environment
          echo "Deploying to production environment..."
          az aks get-credentials --resource-group cst8918-final-project-group-1 --name prod-aks --overwrite-existing
          kubectl apply -f environments/prod/weather-service.yaml
          kubectl rollout status deployment/weather-app -n default --timeout=180s
          
          echo "All applications deployed successfully!"

      # Final verification
      - name: Verify Deployment
        run: |
          echo "=== Deployment Verification ==="
          echo "Test Environment Services:"
          kubectl get services -n default --no-headers | grep weather-app || echo "No weather-app services found"
          echo "Production Environment Services:"
          kubectl get services -n default --no-headers | grep weather-app || echo "No weather-app services found"
          echo "Deployment verification completed!" 